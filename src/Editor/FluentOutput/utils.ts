import { loader } from '@monaco-editor/react';
import monacoThemes from 'monaco-themes/themes/themelist';

function defineTheme(theme: string) {
  return new Promise((res) => {
    Promise.all([
      loader.init(),
      import(`../../../node_modules/monaco-themes/themes/${monacoThemes[theme]}.json`),
    ]).then(([monaco, themeData]) => {
      monaco.editor.defineTheme(theme, themeData);
      res(void 0);
    });
  });
}

// Code below is generated by Gemini
interface MonacoOptionSchema {
  markdownDescription?: string;
  description?: string;
  type?: string | string[];
  enum?: string[];
  enumDescriptions?: string[];
  markdownEnumDescriptions?: string[];
  default?: unknown;
  minimum?: number;
  maximum?: number;
  properties?: Record<string, MonacoOptionSchema>;
}

export interface MonacoOption {
  id: number;
  name: string;
  defaultValue: unknown;
  schema?: MonacoOptionSchema;
  _allowedValues?: string[];
}

interface JsonSchema {
  type: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties: Record<string, any>;
  definitions?: Record<string, unknown>;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function generateDefaultOptionsJson(monacoOptions: MonacoOption[]): Record<string, any> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const defaultOptions: Record<string, any> = {};

  for (const optionName in monacoOptions) {
    if (Object.prototype.hasOwnProperty.call(monacoOptions, optionName)) {
      const option: MonacoOption = monacoOptions[optionName];
      const optionSchema: MonacoOptionSchema | Record<string, MonacoOptionSchema> | undefined =
        option.schema;

      if (optionSchema) {
        let hasNestedOptions = false;

        for (const key in optionSchema) {
          if (key.includes('.')) {
            hasNestedOptions = true;
            break;
          }
        }

        if (hasNestedOptions) {
          defaultOptions[optionName] = {};
          for (const nestedProp in optionSchema) {
            if (Object.prototype.hasOwnProperty.call(optionSchema, nestedProp)) {
              const nestedSchema: MonacoOptionSchema = optionSchema[
                nestedProp as keyof typeof optionSchema
              ] as MonacoOptionSchema;
              const nestedPropertyName = nestedProp.split('.').pop() || '';
              defaultOptions[optionName][nestedPropertyName] = nestedSchema.default;
            }
          }
        } else {
          defaultOptions[optionName] = optionSchema.default ?? option.defaultValue;
        }
      } else {
        defaultOptions[optionName] = option.defaultValue;
      }
    }
  }

  // remove automaticLayout
  delete defaultOptions.automaticLayout;

  return defaultOptions;
}

function generateOptionsJsonSchema(monacoOptions: MonacoOption[]): JsonSchema {
  const schema: JsonSchema = {
    type: 'object',
    properties: {},
    definitions: {},
  };

  for (const optionName in monacoOptions) {
    if (Object.prototype.hasOwnProperty.call(monacoOptions, optionName)) {
      const option = monacoOptions[optionName as keyof typeof monacoOptions] as MonacoOption;
      const optionSchema: MonacoOptionSchema | Record<string, MonacoOptionSchema> | undefined =
        option.schema;

      if (optionSchema) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const propertySchema: Record<string, any> = {};
        let hasNestedOptions = false;

        for (const key in optionSchema) {
          if (key.includes('.')) {
            hasNestedOptions = true;
            break;
          }
        }

        if (hasNestedOptions) {
          propertySchema.type = 'object';
          propertySchema.properties = {};
          for (const nestedProp in optionSchema) {
            if (Object.prototype.hasOwnProperty.call(optionSchema, nestedProp)) {
              const nestedSchema = optionSchema[
                nestedProp as keyof typeof optionSchema
              ] as MonacoOptionSchema;

              if (nestedSchema) {
                const nestedPropertyName = nestedProp.split('.').pop() || '';
                propertySchema.properties[nestedPropertyName] = {
                  type: nestedSchema.type,
                  markdownDescription:
                    nestedSchema.markdownDescription ||
                    nestedSchema.description ||
                    'No description available',
                  default: nestedSchema.default,
                };
                if (nestedSchema.enum) {
                  propertySchema.properties[nestedPropertyName].enum = nestedSchema.enum;
                }
                if (nestedSchema.enumDescriptions) {
                  propertySchema.properties[nestedPropertyName]['x-enumDescriptions'] =
                    nestedSchema.enumDescriptions;
                }
                if (nestedSchema.markdownEnumDescriptions) {
                  propertySchema.properties[nestedPropertyName]['x-enumDescriptions'] =
                    nestedSchema.markdownEnumDescriptions;
                }
                if (nestedSchema.minimum !== undefined) {
                  propertySchema.properties[nestedPropertyName].minimum = nestedSchema.minimum;
                }
                if (nestedSchema.maximum !== undefined) {
                  propertySchema.properties[nestedPropertyName].maximum = nestedSchema.maximum;
                }
              }
            }
          }
        } else {
          propertySchema.markdownDescription =
            optionSchema.markdownDescription ||
            optionSchema.description ||
            'No description available';

          if (optionSchema.type) {
            propertySchema.type = optionSchema.type;
          }

          if (optionSchema.enum) {
            propertySchema.enum = optionSchema.enum;
          }

          if (optionSchema.enumDescriptions) {
            propertySchema['x-enumDescriptions'] = optionSchema.enumDescriptions;
          }
          if (optionSchema.markdownEnumDescriptions) {
            propertySchema['x-enumDescriptions'] = optionSchema.markdownEnumDescriptions;
          }

          if (optionSchema.default !== undefined) {
            propertySchema.default = optionSchema.default;
          }

          if (optionSchema.minimum !== undefined) {
            propertySchema.minimum = optionSchema.minimum;
          }

          if (optionSchema.maximum !== undefined) {
            propertySchema.maximum = optionSchema.maximum;
          }
        }

        schema.properties[optionName] = propertySchema;
      } else {
        // Handle options without a schema
        schema.properties[optionName] = {
          type: typeof option.defaultValue,
          default: option.defaultValue,
          description: 'No description available',
        };
      }
    }
  }

  return schema;
}

export { defineTheme, generateOptionsJsonSchema, generateDefaultOptionsJson };
